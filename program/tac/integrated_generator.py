from typing import List, Optional, Dict, Any
from AST.ast_nodes import ASTNode, Program, FunctionDeclaration, CallExpression, ReturnStatement, ClassDeclaration
from .base_generator import BaseTACVisitor, TACGenerationError
from .expression_generator import ExpressionTACGenerator
from .control_flow_generator import ControlFlowTACGenerator
from .function_generator import FunctionTACGenerator
from .instruction import TACInstruction, CommentInstruction


class IntegratedTACGenerator(BaseTACVisitor):
    """
    Integrated TAC Generator that combines all four parts:
    - Part 1: Infrastructure & Memory Management
    - Part 2: Expression TAC Generation
    - Part 3: Control Flow TAC Generation
    - Part 4: Functions & Activation Records

    This generator coordinates between all components to produce complete
    TAC for CompilScript programs.
    """

    def __init__(self):
        super().__init__()

        # Initialize component generators
        self.expression_generator = ExpressionTACGenerator()
        self.control_flow_generator = ControlFlowTACGenerator()
        self.function_generator = FunctionTACGenerator()

        # Share infrastructure between generators
        self._share_infrastructure()

        # Generator coordination
        self._current_generator_context = 'global'

    def _share_infrastructure(self):
        """Share infrastructure components between generators."""
        # Share temp manager
        self.expression_generator.temp_manager = self.temp_manager
        self.control_flow_generator.temp_manager = self.temp_manager
        self.function_generator.temp_manager = self.temp_manager

        # Share address manager
        self.expression_generator.address_manager = self.address_manager
        self.control_flow_generator.address_manager = self.address_manager
        self.function_generator.address_manager = self.address_manager

        # Share label manager
        self.expression_generator.label_manager = self.label_manager
        self.control_flow_generator.label_manager = self.label_manager
        self.function_generator.label_manager = self.label_manager

        # Set cross-references between function and other generators
        self.function_generator.set_expression_generator(self.expression_generator)
        self.function_generator.set_control_flow_generator(self.control_flow_generator)

        # Set function generator reference in expression and control flow generators
        self.expression_generator._function_generator = self.function_generator
        self.control_flow_generator._function_generator = self.function_generator

    def generate_program(self, program: Program) -> List[str]:
        """
        Generate complete TAC for a CompilScript program.

        Args:
            program: Program AST node

        Returns:
            List[str]: Complete TAC program as strings
        """
        self.reset()
        self.emit(CommentInstruction("TAC Code Generation - CompilScript Compiler"))
        self.emit(CommentInstruction("Generated by IntegratedTACGenerator"))

        # First pass: Register all functions and methods for forward references
        self._register_all_functions(program)

        # Second pass: Process global declarations and statements
        for stmt in program.statements:
            self._process_top_level_statement(stmt)

        return [str(instr) for instr in self.get_instructions()]

    def _register_all_functions(self, program: Program) -> None:
        """
        First pass: Register all functions and class methods for forward references.

        Args:
            program: Program AST node
        """
        for stmt in program.statements:
            if isinstance(stmt, FunctionDeclaration):
                # Register standalone function
                self.function_generator._function_registry[stmt.name] = stmt
            elif isinstance(stmt, ClassDeclaration):
                # Register class and its methods
                self.function_generator._class_registry[stmt.name] = stmt
                for member in stmt.members:
                    if isinstance(member, FunctionDeclaration):
                        # Register both qualified and simple names
                        qualified_name = f"{stmt.name}_{member.name}"
                        self.function_generator._function_registry[qualified_name] = member
                        self.function_generator._function_registry[member.name] = member

    def _process_top_level_statement(self, stmt: ASTNode) -> Optional[str]:
        """
        Process a top-level statement, routing to appropriate generator.

        Args:
            stmt: Statement AST node

        Returns:
            Optional[str]: Result temporary/variable if applicable
        """
        if isinstance(stmt, FunctionDeclaration):
            return self._process_function_declaration(stmt)
        elif isinstance(stmt, ClassDeclaration):
            return self._process_class_declaration(stmt)
        else:
            # Global statement - delegate to appropriate generator
            return self._route_to_generator(stmt)

    def _process_function_declaration(self, func_decl: FunctionDeclaration) -> Optional[str]:
        """
        Process function declaration with proper context management.

        Args:
            func_decl: FunctionDeclaration AST node

        Returns:
            None (function declarations don't return values)
        """
        old_context = self._current_generator_context
        self._current_generator_context = 'function'

        try:
            # Copy current instructions to function generator
            current_instructions = self.get_instructions()
            self.function_generator.instructions = current_instructions

            # Generate function TAC
            result = self.function_generator.visit_FunctionDeclaration(func_decl)

            # Copy back the updated instructions
            self.instructions = self.function_generator.get_instructions()

            return result
        finally:
            self._current_generator_context = old_context

    def _process_class_declaration(self, class_decl: ClassDeclaration) -> Optional[str]:
        """
        Process class declaration with proper context management.

        Args:
            class_decl: ClassDeclaration AST node

        Returns:
            None (class declarations don't return values)
        """
        old_context = self._current_generator_context
        self._current_generator_context = 'class'

        try:
            # Copy current instructions to function generator
            current_instructions = self.get_instructions()
            self.function_generator.instructions = current_instructions

            # Generate class TAC (includes all methods)
            result = self.function_generator.visit_ClassDeclaration(class_decl)

            # Copy back the updated instructions
            self.instructions = self.function_generator.get_instructions()

            return result
        finally:
            self._current_generator_context = old_context

    def _route_to_generator(self, node: ASTNode) -> Optional[str]:
        """
        Route AST node to appropriate generator based on node type.

        Args:
            node: AST node to process

        Returns:
            Optional[str]: Result temporary/variable if applicable
        """
        node_type = node.__class__.__name__

        # Function-related nodes
        if isinstance(node, (CallExpression, ReturnStatement)):
            return self._delegate_to_function_generator(node)

        # Print statement (treated as function call)
        elif node_type == 'PrintStatement':
            return self._delegate_to_function_generator(node)

        # Control flow nodes (including VariableDeclaration which may appear in blocks)
        elif node_type in ['IfStatement', 'WhileStatement', 'ForStatement',
                          'DoWhileStatement', 'SwitchStatement', 'BreakStatement',
                          'ContinueStatement', 'Block', 'ForEachStatement', 'TryCatchStatement',
                          'VariableDeclaration']:
            return self._delegate_to_control_flow_generator(node)

        # Expression nodes
        elif node_type in ['BinaryExpression', 'UnaryExpression', 'AssignmentStatement',
                          'Identifier', 'Literal', 'PropertyAccess', 'IndexExpression',
                          'NewExpression', 'BinaryOperation']:
            return self._delegate_to_expression_generator(node)

        else:
            # Try generic visit
            return self.visit(node)

    def _delegate_to_expression_generator(self, node: ASTNode) -> Optional[str]:
        """Delegate to expression generator with state synchronization."""
        # Sync current instructions
        current_instructions = self.get_instructions()
        self.expression_generator.instructions = current_instructions

        # Generate expression TAC
        result = self.expression_generator.generate(node)

        # Sync back instructions
        self.instructions = self.expression_generator.get_instructions()

        return result

    def _delegate_to_control_flow_generator(self, node: ASTNode) -> Optional[str]:
        """Delegate to control flow generator with state synchronization."""
        # Sync current instructions
        current_instructions = self.get_instructions()
        self.control_flow_generator.instructions = current_instructions

        # Generate control flow TAC
        result = self.control_flow_generator.generate(node)

        # Sync back instructions
        self.instructions = self.control_flow_generator.get_instructions()

        return result

    def _delegate_to_function_generator(self, node: ASTNode) -> Optional[str]:
        """Delegate to function generator with state synchronization."""
        # Sync current instructions
        current_instructions = self.get_instructions()
        self.function_generator.instructions = current_instructions

        # Generate function TAC
        if isinstance(node, CallExpression):
            result = self.function_generator.visit_CallExpression(node)
        elif isinstance(node, ReturnStatement):
            result = self.function_generator.visit_ReturnStatement(node)
        elif node.__class__.__name__ == 'PrintStatement':
            result = self.function_generator.visit_PrintStatement(node)
        else:
            result = self.function_generator.generate(node)

        # Sync back instructions
        self.instructions = self.function_generator.get_instructions()

        return result

    def get_complete_statistics(self) -> Dict[str, Any]:
        """
        Get comprehensive statistics from all generator components.

        Returns:
            Dict[str, Any]: Complete statistics
        """
        base_stats = self.get_statistics()

        return {
            'integrated_stats': base_stats,
            'expression_stats': self.expression_generator.get_statistics(),
            'control_flow_stats': self.control_flow_generator.get_statistics(),
            'function_stats': self.function_generator.get_statistics(),
            'total_instructions': len(self.get_instructions()),
            'generator_context': self._current_generator_context
        }

    def reset(self):
        """Reset all generator components to initial state."""
        super().reset()
        self.expression_generator.reset()
        self.control_flow_generator.reset()
        self.function_generator.reset()
        self._current_generator_context = 'global'
        self._share_infrastructure()

    def get_tac_with_metadata(self) -> Dict[str, Any]:
        """
        Get TAC with additional metadata for debugging and optimization.

        Returns:
            Dict[str, Any]: TAC code with metadata
        """
        instructions = self.get_instructions()

        return {
            'tac_code': [str(instr) for instr in instructions],
            'instruction_count': len(instructions),
            'function_registry': self.function_generator._function_registry.keys(),
            'statistics': self.get_complete_statistics(),
            'memory_layout': {
                'global_vars': len(self.address_manager._global_vars),
                'active_functions': len(self.address_manager._activation_records),
                'labels_generated': self.address_manager._label_counter
            }
        }

    def optimize_tac(self) -> List[str]:
        """
        Apply basic optimizations to generated TAC.

        Returns:
            List[str]: Optimized TAC instructions
        """
        instructions = self.get_instructions()
        optimized = []

        i = 0
        while i < len(instructions):
            current = instructions[i]

            # Skip consecutive identical comments
            if (isinstance(current, CommentInstruction) and
                i + 1 < len(instructions) and
                isinstance(instructions[i + 1], CommentInstruction) and
                str(current) == str(instructions[i + 1])):
                i += 1  # Skip duplicate
                continue

            optimized.append(current)
            i += 1

        return [str(instr) for instr in optimized]

    def validate_tac(self) -> List[str]:
        """
        Validate generated TAC for common errors.

        Returns:
            List[str]: List of validation errors (empty if valid)
        """
        errors = []
        instructions = self.get_instructions()

        # Check for unmatched function begin/end
        func_stack = []
        for instr in instructions:
            if hasattr(instr, 'name'):
                if 'BeginFunc' in str(type(instr)):
                    func_stack.append(instr.name)
                elif 'EndFunc' in str(type(instr)):
                    if not func_stack:
                        errors.append("EndFunc without matching BeginFunc")
                    else:
                        expected = func_stack.pop()
                        if expected != instr.name:
                            errors.append(f"Function name mismatch: expected {expected}, got {instr.name}")

        if func_stack:
            errors.append(f"Unmatched BeginFunc instructions: {func_stack}")

        # Check for undefined labels (basic check)
        defined_labels = set()
        referenced_labels = set()

        for instr in instructions:
            if hasattr(instr, 'label'):
                if 'Label' in str(type(instr)):
                    defined_labels.add(instr.label)
                elif 'Goto' in str(type(instr)):
                    referenced_labels.add(instr.label)

        undefined_labels = referenced_labels - defined_labels
        if undefined_labels:
            errors.append(f"Undefined labels: {undefined_labels}")

        return errors